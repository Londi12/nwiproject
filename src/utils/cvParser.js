// Enhanced CV Parser Utility Functions
// Converted from TypeScript implementation for comprehensive CV parsing

export const detectFileTypeFromName = (fileName) => {
  const extension = fileName.split('.').pop().toLowerCase();
  return extension;
};

// Supported file types for CV parsing
export const CVFileType = {
  PDF: 'pdf',
  DOCX: 'docx',
  TXT: 'txt',
  UNKNOWN: 'unknown'
};

export const TemplateType = {
  PROFESSIONAL: 'professional',
  MODERN: 'modern',
  CREATIVE: 'creative',
  SIMPLE: 'simple',
  EXECUTIVE: 'executive',
  TECHNICAL: 'technical',
  GRADUATE: 'graduate',
  DIGITAL: 'digital'
};

/**
 * Detect if this is one of our own templates
 */
function detectOwnTemplate(text) {
  // Look for our template markers
  const templateMarkers = [
    { type: TemplateType.PROFESSIONAL, patterns: ['professional template', 'corporate professional', 'cvkonnekt professional'] },
    { type: TemplateType.MODERN, patterns: ['modern template', 'modern minimalist', 'cvkonnekt modern'] },
    { type: TemplateType.CREATIVE, patterns: ['creative template', 'creative design', 'cvkonnekt creative'] },
    { type: TemplateType.SIMPLE, patterns: ['simple template', 'simple clean', 'cvkonnekt simple'] },
    { type: TemplateType.EXECUTIVE, patterns: ['executive template', 'executive elite', 'cvkonnekt executive'] },
    { type: TemplateType.TECHNICAL, patterns: ['technical template', 'technical expert', 'cvkonnekt technical'] },
    { type: TemplateType.GRADUATE, patterns: ['graduate template', 'graduate entry', 'cvkonnekt graduate'] },
    { type: TemplateType.DIGITAL, patterns: ['digital template', 'digital portfolio', 'cvkonnekt digital'] }
  ];

  const lowerText = text.toLowerCase();

  for (const marker of templateMarkers) {
    for (const pattern of marker.patterns) {
      if (lowerText.includes(pattern)) {
        return { isOwnTemplate: true, templateType: marker.type };
      }
    }
  }

  // Also check for our specific formatting patterns
  if (lowerText.includes('cvkonnekt') || lowerText.includes('generated by cvkonnekt')) {
    return { isOwnTemplate: true, templateType: TemplateType.PROFESSIONAL };
  }

  return { isOwnTemplate: false };
}

export const parseTextToCV = (rawText, isOwnTemplate = false) => {
  try {
    console.log('Starting CV parsing with text:', rawText.substring(0, 200) + '...'); // Debug log

    const personalInfo = extractPersonalInfo(rawText);
    console.log('Extracted personal info:', personalInfo); // Debug log

    const summary = extractSummary(rawText);
    console.log('Extracted summary:', summary.substring(0, 100) + '...'); // Debug log

    const experience = extractExperience(rawText);
    console.log('Extracted experience:', experience); // Debug log

    const education = extractEducation(rawText);
    console.log('Extracted education:', education); // Debug log

    const skills = extractSkills(rawText);
    console.log('Extracted skills:', skills); // Debug log

    const cvData = {
      personalInfo,
      summary,
      experience,
      education,
      skills,
      projects: []
    };

    const confidence = calculateConfidence(cvData, isOwnTemplate);
    console.log('Final CV data:', cvData); // Debug log
    console.log('Confidence score:', confidence); // Debug log

    return {
      success: true,
      data: cvData,
      rawText: rawText,
      confidence,
      ownTemplate: isOwnTemplate
    };
  } catch (error) {
    console.error('Error parsing text to CV:', error);
    return {
      success: false,
      error: error.message || 'Unknown error',
      confidence: 0,
      data: {
        personalInfo: {
          fullName: "",
          jobTitle: "",
          email: "",
          phone: "",
          location: ""
        },
        summary: "",
        experience: [],
        education: [],
        skills: [],
        projects: []
      }
    };
  }
};

/**
 * Extract personal information from text
 */
function extractPersonalInfo(text) {
  // Clean the text first
  const cleanText = text.replace(/\r\n/g, '\n').replace(/\t/g, ' ');

  // Extract name from the first line (assuming it's the first non-empty line)
  const lines = cleanText.split('\n').filter(line => line.trim());
  const firstLine = lines[0] || '';

  console.log('First line for name extraction:', firstLine); // Debug log

  // Try multiple patterns for name extraction
  let fullName = '';

  // Pattern 1: Name before any contact info (email, phone, etc.)
  const nameMatch1 = firstLine.match(/^([^|@\d\n\r]+?)(?:\s*\||\s*@|\s*\d|$)/);
  if (nameMatch1 && nameMatch1[1].trim().length > 2) {
    fullName = nameMatch1[1].trim();
  }

  // Pattern 2: Look for capitalized name pattern
  if (!fullName) {
    const nameMatch2 = firstLine.match(/^([A-Z][a-z]+(?:\s+[A-Z][a-z]+)+)/);
    if (nameMatch2) {
      fullName = nameMatch2[1].trim();
    }
  }

  // Pattern 3: Look for name in the first few lines
  if (!fullName) {
    for (let i = 0; i < Math.min(5, lines.length); i++) {
      const line = lines[i].trim();
      // More flexible name pattern for PDF files
      const nameMatch = line.match(/^([A-Z][a-z]+(?:\s+[A-Z][a-z]+)+)/) ||
                        line.match(/^([A-Z][A-Z]+\s+[A-Z][a-z]+)/) ||  // ALL CAPS first name
                        line.match(/^([A-Z][a-z]+\s+[A-Z][A-Z]+)/);    // ALL CAPS last name
      if (nameMatch && nameMatch[1].length > 3) {
        fullName = nameMatch[1].trim();
        break;
      }
    }
  }

  console.log('Extracted name:', fullName); // Debug log

  // Look for professional summary or job title
  let jobTitle = '';

  // First try to find a job title in a professional summary section
  const summaryMatch = cleanText.match(/(?:professional\s+summary|profile|summary)[\s:]*\n+([^\n]+)/i);
  if (summaryMatch && summaryMatch[1].length < 100) { // Not too long to be a full summary
    jobTitle = summaryMatch[1].trim();
  }

  // Look for job title patterns in the first few lines after the name
  if (!jobTitle) {
    for (let i = 1; i < Math.min(8, lines.length); i++) {
      const line = lines[i].trim();

      // Skip lines that look like contact info or addresses
      if (line.includes('@') ||
          line.includes('|') ||
          line.match(/\(\d{3}\)/) ||
          line.match(/\d+\s+\w+\s+(Street|St|Avenue|Ave|Road|Rd|Boulevard|Blvd|Lane|Ln|Drive|Dr)/i) ||
          line.match(/^\d+\s/) || // Starts with a number (likely address)
          line.includes(',') && line.match(/\d{5}/) // Contains zip code
         ) {
        continue;
      }

      // Look for job title patterns - professional titles
      if ((line.match(/^[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*$/) ||
           line.match(/Manager|Director|Engineer|Developer|Analyst|Coordinator|Specialist|Assistant|Executive|Officer|Consultant|Administrator|Supervisor|Lead|Senior|Junior/i)) &&
          line.length < 60 &&
          line.length > 5 &&
          !line.match(/\d{4}/) && // Not a date
          !line.match(/Profile|Summary|Experience|Education|Skills|Contact/i)) { // Not a section header
        jobTitle = line;
        break;
      }
    }
  }

  // If still not found, look for job title in the experience section
  if (!jobTitle) {
    const jobTitleMatch = cleanText.match(/(?:^|\n)([^|\n\r]+?)\s*\|\s*[^|\n\r]+(?:\s*â€“|\s*to|\s*-)/im) ||
                          cleanText.match(/(?:job title|position|role)[\s:]*([^\n]+)/i);
    if (jobTitleMatch) {
      jobTitle = jobTitleMatch[1].trim();
    }
  }

  // Look for email with more flexible pattern
  const emailMatch = cleanText.match(/([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/);
  const email = emailMatch ? emailMatch[1].trim() : '';

  // Look for phone number with various formats
  // First try to find a phone number in standard US format (XXX) XXX-XXXX
  const usPhoneMatch = cleanText.match(/\((\d{3})\)\s*(\d{3})-(\d{4})/);

  // Then try other international formats
  const phoneMatch = !usPhoneMatch && (
    cleanText.match(/(?:^|\s)(?:\+\d{1,3}|0)?[\s.-]?(\d{1,3})[\s.-]?(\d{3})[\s.-]?(\d{4})(?:\s|$)/) ||
    cleanText.match(/(?:phone|tel|mobile|cell)[\s:]*([+\d\s.-]{7,})/i)
  );

  let phone = '';
  if (usPhoneMatch) {
    // Preserve the US format
    phone = `(${usPhoneMatch[1]}) ${usPhoneMatch[2]}-${usPhoneMatch[3]}`;
  } else if (phoneMatch) {
    if (phoneMatch[1] && phoneMatch[2] && phoneMatch[3]) {
      // Format the phone number consistently if we have the parts
      phone = `${phoneMatch[1]}-${phoneMatch[2]}-${phoneMatch[3]}`;
    } else if (phoneMatch[1]) {
      // Just use the matched phone string
      phone = phoneMatch[1].trim();
    }
  }

  // Look for location/address with more flexible patterns
  let location = '';

  // Try multiple location patterns, being more specific to avoid job titles
  const locationPatterns = [
    // Full address with street number and zip
    /(\d+\s+[^|\n\r]+?(?:Street|St|Avenue|Ave|Road|Rd|Boulevard|Blvd|Lane|Ln|Drive|Dr)[^|\n\r]*?,\s*[^|\n\r]+?,\s*[A-Z]{2}\s*\d{5})/im,
    // Street address with city and state
    /(\d+\s+[^|\n\r]+?(?:Street|St|Avenue|Ave|Road|Rd|Boulevard|Blvd|Lane|Ln|Drive|Dr)[^|\n\r]*?,\s*[^|\n\r]+?,\s*[A-Z]{2})/im,
    // Just street address
    /(\d+\s+[^|\n\r]+?(?:Street|St|Avenue|Ave|Road|Rd|Boulevard|Blvd|Lane|Ln|Drive|Dr))/im,
    // City, State, ZIP format
    /([A-Z][a-z]+,\s*[A-Z]{2}\s*\d{5})/,
    // City, State format
    /([A-Z][a-z]+,\s*[A-Z]{2})/,
    // Address labeled
    /(?:address|location)[\s:]*([^\n]+)/i
  ];

  for (const pattern of locationPatterns) {
    const match = cleanText.match(pattern);
    if (match && match[1]) {
      const potentialLocation = match[1].trim();
      // Make sure it's not a job title or name
      if (!potentialLocation.match(/^[A-Z][a-z]+\s+[A-Z][a-z]+$/) ||
          potentialLocation.includes(',') ||
          potentialLocation.match(/\d/)) {
        location = potentialLocation;
        break;
      }
    }
  }

  console.log('Extracted personal info:', { fullName, jobTitle, email, phone, location }); // Debug log

  return {
    fullName,
    jobTitle,
    email,
    phone,
    location
  };
}

/**
 * Extract summary from text
 */
function extractSummary(text) {
  // Look for profile/summary section with more flexible patterns
  const profilePatterns = [
    // Standard section header with content until next major section
    /(?:profile|summary|professional\s+summary|objective|about\s+me)[:.\s]*\n+([^]*?)(?=\n\s*(?:experience|education|skills|activities|interests|work|employment):)/i,

    // Look for PROFESSIONAL SUMMARY as a standalone header until next major section
    /PROFESSIONAL\s+SUMMARY\s*\n+([^]*?)(?=\n\s*(?:EXPERIENCE|EDUCATION|SKILLS|WORK|EMPLOYMENT):)/i,

    // Section header without clear end marker but ending at a capitalized section header
    /(?:profile|summary|professional\s+summary|objective|about\s+me)[:.\s]*\n+([^]*?)(?=\n\s*\n\s*[A-Z][A-Z\s]+\s*\n)/i,

    // Section header with content until double newline (less strict fallback)
    /(?:profile|summary|professional\s+summary|objective|about\s+me)[:.\s]*\n+([^]*?)(?=\n\s*\n)/i
  ];

  for (const pattern of profilePatterns) {
    const match = text.match(pattern);
    if (match && match[1] && match[1].trim()) {
      // Clean up the summary
      let summary = match[1].trim()
        .replace(/^\s*[-â€¢*]\s*/gm, '') // Remove bullet points
        .replace(/\n+/g, ' '); // Join multiple lines

      console.log('Summary found with pattern:', summary.substring(0, 100) + '...'); // Debug log
      return summary;
    }
  }

  // Fallback: look for any paragraph that seems like a summary
  // Usually appears near the top of the document after the contact info
  const lines = text.split('\n');
  const startLine = Math.min(15, lines.length); // Look in the first 15 lines (increased from 10)

  // Look for a substantial paragraph in the first few lines
  for (let i = 0; i < startLine; i++) {
    const line = lines[i].trim();
    // Look for a substantial paragraph that's likely to be a summary
    if (line.length > 50 && !line.includes('|') && !line.includes('@') && !line.match(/^\d/) &&
        !line.match(/^(education|experience|skills|work|employment)/i)) {
      console.log('Summary found in first lines:', line.substring(0, 100) + '...'); // Debug log
      return line;
    }
  }

  // Second fallback: look for a longer paragraph anywhere in the first part of the document
  const firstThird = lines.slice(0, Math.floor(lines.length / 3));
  for (const line of firstThird) {
    if (line.length > 80) { // Reduced from 100 to catch more potential summaries
      console.log('Summary found in first third:', line.substring(0, 100) + '...'); // Debug log
      return line;
    }
  }

  // Third fallback: try to find multiple consecutive lines that might form a summary
  for (let i = 0; i < startLine; i++) {
    if (lines[i].trim().length > 30 && lines[i+1] && lines[i+1].trim().length > 30) {
      const combinedLines = lines.slice(i, i+3).join(' ').trim();
      if (combinedLines.length > 60) {
        console.log('Summary found from consecutive lines:', combinedLines.substring(0, 100) + '...'); // Debug log
        return combinedLines;
      }
    }
  }

  console.log('No summary found'); // Debug log
  return '';
}

/**
 * Extract experience from text (enhanced version)
 */
function extractExperience(text) {
  const experiences = [];
  console.log('Extracting experience from text...');

  // Multiple patterns to match experience sections
  const experiencePatterns = [
    /(?:work\s+experience|professional\s+experience|employment\s+history|career\s+history|experience)[:.\s]*\n([^]*?)(?=\n\s*(?:education|skills|qualifications|certifications|projects|activities|references)[:.\s]*\n)/is,
    /(?:work\s+experience|professional\s+experience|employment\s+history|career\s+history|experience)[:.\s]*\n([^]*?)(?=\n\s*[A-Z][A-Z\s]+\s*\n)/is,
    /(?:work\s+experience|professional\s+experience|employment\s+history|career\s+history|experience)[:.\s]*\n([^]*?)$/is
  ];

  let experienceText = '';
  for (const pattern of experiencePatterns) {
    const match = text.match(pattern);
    if (match && match[1] && match[1].trim().length > 20) {
      experienceText = match[1].trim();
      console.log('Found experience section:', experienceText.substring(0, 100) + '...');
      break;
    }
  }

  if (experienceText) {
    // Split by common job entry patterns
    const jobEntries = experienceText.split(/\n(?=\s*[A-Z][^|\n]*(?:\||at|@|\n))/);

    for (const entry of jobEntries) {
      const trimmedEntry = entry.trim();
      if (trimmedEntry.length < 10) continue;

      let experience = {
        title: '',
        company: '',
        location: '',
        startDate: '',
        endDate: '',
        description: ''
      };

      // Pattern 1: Title | Company | Location | Dates
      if (trimmedEntry.includes('|')) {
        const parts = trimmedEntry.split('|').map(part => part.trim());
        experience.title = parts[0] || '';
        experience.company = parts[1] || '';
        experience.location = parts[2] || '';
        const datesPart = parts[3] || '';
        const dateMatch = datesPart.match(/(\d{4}|\w+\s+\d{4})\s*[-â€“â€”]\s*(\d{4}|\w+\s+\d{4}|present|current)/i);
        if (dateMatch) {
          experience.startDate = dateMatch[1];
          experience.endDate = dateMatch[2];
        }
      } else {
        // Pattern 2: Multi-line format
        const lines = trimmedEntry.split('\n').map(line => line.trim()).filter(line => line);

        if (lines.length >= 2) {
          // First line is usually the job title
          experience.title = lines[0];

          // Look for company name (often contains "at", "Company:", or is the second line)
          for (let i = 1; i < lines.length; i++) {
            const line = lines[i];
            if (line.toLowerCase().includes('company:') || line.toLowerCase().includes('employer:')) {
              experience.company = line.replace(/^(company|employer):\s*/i, '');
              break;
            } else if (line.match(/^[A-Z][^.!?]*$/) && !line.match(/^\d/) && line.length < 100) {
              experience.company = line;
              break;
            }
          }

          // Look for dates
          const fullText = trimmedEntry;
          const dateMatch = fullText.match(/(\d{1,2}\/\d{4}|\w+\s+\d{4}|\d{4})\s*[-â€“â€”]\s*(\d{1,2}\/\d{4}|\w+\s+\d{4}|\d{4}|present|current)/i);
          if (dateMatch) {
            experience.startDate = dateMatch[1];
            experience.endDate = dateMatch[2];
          }

          // Look for location
          const locationMatch = fullText.match(/(?:location|address):\s*([^|\n]+)/i) ||
                               fullText.match(/([A-Z][a-z]+,\s*[A-Z]{2,})/);
          if (locationMatch) {
            experience.location = locationMatch[1].trim();
          }

          // Extract description (usually after the basic info)
          const descriptionLines = lines.slice(2).filter(line =>
            !line.match(/^\d{4}/) &&
            !line.toLowerCase().includes('location:') &&
            !line.toLowerCase().includes('company:') &&
            line.length > 10
          );
          if (descriptionLines.length > 0) {
            experience.description = descriptionLines.join(' ');
          }
        }
      }

      // Only add if we have at least a title or company
      if (experience.title || experience.company) {
        experiences.push(experience);
        console.log('Added experience:', experience);
      }
    }
  }

  // Fallback: look for any job-like patterns in the text
  if (experiences.length === 0) {
    const jobTitlePatterns = [
      /(?:^|\n)\s*([A-Z][^|\n]*(?:engineer|developer|manager|analyst|specialist|coordinator|assistant|director|supervisor|lead|senior|junior)[^|\n]*)/gim,
      /(?:^|\n)\s*([A-Z][^|\n]*(?:at|@)\s+[A-Z][^|\n]*)/gim
    ];

    for (const pattern of jobTitlePatterns) {
      const matches = text.matchAll(pattern);
      for (const match of matches) {
        if (match[1] && match[1].trim().length > 5) {
          const parts = match[1].split(/\s+(?:at|@)\s+/);
          experiences.push({
            title: parts[0] ? parts[0].trim() : '',
            company: parts[1] ? parts[1].trim() : '',
            location: '',
            startDate: '',
            endDate: '',
            description: ''
          });
        }
      }
    }
  }

  console.log('Final extracted experiences:', experiences);
  return experiences;
}

/**
 * Extract education from text (enhanced version)
 */
function extractEducation(text) {
  const education = [];
  console.log('Extracting education from text...');

  // Multiple patterns to match education sections
  const educationPatterns = [
    /(?:education|academic\s+background|qualifications|academic\s+qualifications)[:.\s]*\n([^]*?)(?=\n\s*(?:experience|skills|work|employment|certifications|projects|activities|references)[:.\s]*\n)/is,
    /(?:education|academic\s+background|qualifications|academic\s+qualifications)[:.\s]*\n([^]*?)(?=\n\s*[A-Z][A-Z\s]+\s*\n)/is,
    /(?:education|academic\s+background|qualifications|academic\s+qualifications)[:.\s]*\n([^]*?)$/is
  ];

  let educationText = '';
  for (const pattern of educationPatterns) {
    const match = text.match(pattern);
    if (match && match[1] && match[1].trim().length > 10) {
      educationText = match[1].trim();
      console.log('Found education section:', educationText.substring(0, 100) + '...');
      break;
    }
  }

  if (educationText) {
    // Split by common education entry patterns
    const eduEntries = educationText.split(/\n(?=\s*[A-Z][^|\n]*(?:\||at|@|,|\n))/);

    for (const entry of eduEntries) {
      const trimmedEntry = entry.trim();
      if (trimmedEntry.length < 10) continue;

      let eduItem = {
        degree: '',
        institution: '',
        location: '',
        graduationDate: ''
      };

      // Pattern 1: Degree | Institution | Location | Date
      if (trimmedEntry.includes('|')) {
        const parts = trimmedEntry.split('|').map(part => part.trim());
        eduItem.degree = parts[0] || '';
        eduItem.institution = parts[1] || '';
        eduItem.location = parts[2] || '';
        eduItem.graduationDate = parts[3] || '';
      } else {
        // Pattern 2: Multi-line format
        const lines = trimmedEntry.split('\n').map(line => line.trim()).filter(line => line);

        if (lines.length >= 1) {
          // First line is usually the degree
          eduItem.degree = lines[0];

          // Look for institution name
          for (let i = 1; i < lines.length; i++) {
            const line = lines[i];
            if (line.toLowerCase().includes('university') ||
                line.toLowerCase().includes('college') ||
                line.toLowerCase().includes('institute') ||
                line.toLowerCase().includes('school') ||
                line.match(/^[A-Z][^.!?]*$/) && line.length < 100) {
              eduItem.institution = line;
              break;
            }
          }

          // Look for graduation date
          const fullText = trimmedEntry;
          const dateMatch = fullText.match(/(\d{4}|\w+\s+\d{4})/);
          if (dateMatch) {
            eduItem.graduationDate = dateMatch[1];
          }

          // Look for location
          const locationMatch = fullText.match(/([A-Z][a-z]+,\s*[A-Z]{2,})/);
          if (locationMatch) {
            eduItem.location = locationMatch[1].trim();
          }
        }
      }

      // Only add if we have at least a degree or institution
      if (eduItem.degree || eduItem.institution) {
        education.push(eduItem);
        console.log('Added education:', eduItem);
      }
    }
  }

  // Fallback: look for degree patterns anywhere in the text
  if (education.length === 0) {
    const degreePatterns = [
      /(?:bachelor|master|phd|doctorate|diploma|certificate|degree)(?:\s+of|\s+in)?\s+[^|\n]+/gim,
      /(?:b\.?a\.?|b\.?s\.?|m\.?a\.?|m\.?s\.?|ph\.?d\.?|m\.?b\.?a\.?)\s+[^|\n]+/gim
    ];

    for (const pattern of degreePatterns) {
      const matches = text.matchAll(pattern);
      for (const match of matches) {
        if (match[0] && match[0].trim().length > 5) {
          education.push({
            degree: match[0].trim(),
            institution: '',
            location: '',
            graduationDate: ''
          });
        }
      }
    }
  }

  console.log('Final extracted education:', education);
  return education;
}

/**
 * Extract skills from text (simplified version)
 */
function extractSkills(text) {
  const skills = [];

  // Look for skills section
  const skillsMatch = text.match(/(?:skills|competencies)[:.\s]*\n([^]*?)(?=\n\s*(?:experience|education|activities):)/is);

  if (skillsMatch) {
    const skillsText = skillsMatch[1];

    if (skillsText.includes(',')) {
      const skillList = skillsText.split(',').map(skill => skill.trim()).filter(skill => skill.length > 0);
      skillList.forEach(skill => {
        skills.push({
          name: skill,
          category: inferSkillCategory(skill)
        });
      });
    }
  }

  // Fallback: look for common skills
  const commonSkills = [
    'JavaScript', 'Python', 'Java', 'React', 'Node.js', 'SQL', 'HTML', 'CSS',
    'Project Management', 'Leadership', 'Communication', 'Teamwork', 'Analysis',
    'Microsoft Office', 'Excel', 'PowerPoint', 'Word'
  ];

  const textLower = text.toLowerCase();
  commonSkills.forEach(skill => {
    if (textLower.includes(skill.toLowerCase()) && !skills.find(s => s.name.toLowerCase() === skill.toLowerCase())) {
      skills.push({
        name: skill,
        category: inferSkillCategory(skill)
      });
    }
  });

  return skills;
}

/**
 * Infer skill category based on skill name
 */
function inferSkillCategory(skill) {
  const skillLower = skill.toLowerCase();

  if (skillLower.includes('javascript') || skillLower.includes('typescript') || skillLower.includes('react') || skillLower.includes('node')) {
    return 'Programming';
  }
  if (skillLower.includes('python') || skillLower.includes('java') || skillLower.includes('c++')) {
    return 'Programming';
  }
  if (skillLower.includes('excel') || skillLower.includes('word') || skillLower.includes('powerpoint')) {
    return 'Office';
  }
  if (skillLower.includes('photoshop') || skillLower.includes('illustrator') || skillLower.includes('figma')) {
    return 'Design';
  }

  return 'Other';
}

/**
 * Calculate confidence score for parsed data
 */
function calculateConfidence(cvData, isOwnTemplate = false) {
  let score = 0;

  // Base scoring for all CVs
  if (cvData.personalInfo.fullName) score += 15;
  if (cvData.personalInfo.jobTitle) score += 10;
  if (cvData.personalInfo.email) score += 10;
  if (cvData.personalInfo.phone) score += 8;
  if (cvData.personalInfo.location) score += 7;
  if (cvData.summary) score += 12;
  if (cvData.experience.length > 0) score += 15;
  if (cvData.education.length > 0) score += 10;
  if (typeof cvData.skills === 'string' && cvData.skills.trim()) {
    score += 8;
  } else if (Array.isArray(cvData.skills) && cvData.skills.length > 0) {
    score += 8;
  }

  // Bonus for our own templates (they should have higher confidence)
  if (isOwnTemplate) {
    score += 20; // 20% bonus for our own templates
    console.log('Own template detected - applying confidence bonus');
  }

  // Additional bonuses for completeness
  if (cvData.personalInfo.fullName && cvData.personalInfo.email && cvData.personalInfo.phone) {
    score += 5; // Complete contact info bonus
  }

  if (cvData.experience.length >= 2) {
    score += 5; // Multiple experiences bonus
  }

  if (cvData.education.length >= 2) {
    score += 3; // Multiple education entries bonus
  }

  return Math.min(score, 100);
}
